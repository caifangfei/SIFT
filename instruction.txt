       这是一种实时的SIFT匹配算法实现方法，全由FPGA编写构成。通过MATLAB将RGB图片转换成8位灰度图片，再
生成txt数据文件，这里设定成image1.txt和image2.txt。
       通过USB传输数据给FPGA，FPGA处理好后再将匹配到的位置传回PC端，让MATLAB读取这些位置，显示在图片上。
工程分为构建高斯金字塔、生成特征点、生成描述子和匹配四个部分。高斯金字塔我用的一组四层，因为简单。就是用不
同的高斯核滤出来四张图片，两两相减构建DOG金字塔，四层出三张DOG图。特征点需要最“突出”的点--极值点，如果
一个DOG像素点比上下左右26个点都大，它就是特征点。当然，介于数字的不连贯性，它还应该有个更正的过程，去除边
缘效应，但是太麻烦了我没做。
       选好特征点，就要开始做描述子，保证它的旋转不变性和尺度不变性。尺度不变就是高斯金字塔，我金字塔做的简单，
如果做更多组、更多层，就能得到更多的特征点、更多的匹配点。旋转不变性就要确定特征点的主方向了，得到主方向再
把特征点附近的邻域旋转到主方向，这样图片旋转了也能匹配到。按照一般的SIFT方法，需要一个大的方形区域算主方向
再在里面划个圆旋转，然后在圆里面划一个方形区域，割成16个子域分别算直方图，这个直方图是每个像素点按8个方向
分布的数值和。选用的数值是离DOG最近的那张高斯图，过一遍Sobel求梯度，这样就能得到128维的描述子。
       这样的方法用Verilog写，超出了我的知识范围。我查阅文献，用了化圆的方法求描述子。就是将16个方形子域换成
4个同心圆，圆的直径按高斯核的sigma选，我用的9、8、5、2。8个方向换成16个，得到64维描述子，也能用。因为我
代码全用Verilog写的，所以为更一步简化代码，我把同心圆换成了八边形，旋转到主方向一样只需要换位置，比如90°的
主方向只用将原方向0的值换到方向3。
       匹配图和模板图的描述子求出来后只需要计算它们之间的欧氏距离，最近的比次近的一半都小，说明它就是匹配点。
也有用深度学习KD树匹配的，但特征点少于1500的用遍历就行。
       我最先是用MATLAB硬写了SIFT算法，在移植到FPGA上面，FPGA不用浮点，小数我都乘256变成整数，节省资源。
       MATLAB部分，SIFT_wr是将RGB图像转成灰度数据输出去，SIFT_rd是读位置，将两幅图匹配到的位置连线，SIFT
是我最先写的SIFT算法，可移植到FPGA上面。
       FPGA里面，有Creat_Describe生成描述子和Get_Feature得到特征点两部分。Get_Feature里面Guass和Cordic就是
高斯滤波和求模求像素点方向，sobel算法求梯度，compare比较当前点和周围26个数值大小，选特征点。Creat_Describe
里面最麻烦的是seed_addr，选八边形子域，这选出来的4个八边形、16个方向的直方图，直接构成64维描述子。Histogram
求直方图，子域内16个方向的模值之和，最大的那个就是主方向。Sort是比较大小，选主方向用的。rotate旋转到主方向。
Get_describe算顶层文件，生成描述子。最后有个归一化过程，这也是资源消耗最严重的部分，有四个除法器。Match就
是匹配了，选出最近邻和次近邻，得到匹配位置。
       仿真测得，100MHZ下，用时13.5ms；WNS 0.225ns，LUT为28778，FF为30377，BRAM为60。两幅图分别为
388和374个特征点，检测到77个匹配点。
       最后，程序是没有注释的，因为我最讨厌的两件事就是：写注释和别人不写注释。不过这玩意应该没人看，也就无所谓啦。
       Bye~
